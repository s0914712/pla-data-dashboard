<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="utf-8">
    <title>ML Prediction - PLA Sorties Dashboard</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <meta name="description" content="7-day machine learning predictions for PLA aircraft sorties using ensemble models. Historical accuracy analysis and prediction error tracking.">
    <meta name="keywords" content="PLA prediction, machine learning, aircraft sorties forecast, Taiwan Strait, military AI, ensemble model">
    <meta name="author" content="Jeremy Chen">
    <meta name="robots" content="index, follow">
    <link rel="canonical" href="https://s0914712.github.io/pla-data-dashboard/prediction.html">

    <!-- Open Graph -->
    <meta property="og:type" content="website">
    <meta property="og:url" content="https://s0914712.github.io/pla-data-dashboard/prediction.html">
    <meta property="og:title" content="ML Prediction - PLA Sorties Dashboard">
    <meta property="og:description" content="7-day machine learning predictions for PLA aircraft sorties using ensemble models.">
    <meta property="og:image" content="https://s0914712.github.io/pla-data-dashboard/images/og-image.png">
    <meta property="og:locale" content="zh_TW">

    <!-- Twitter Card -->
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:title" content="ML Prediction - PLA Sorties Dashboard">
    <meta name="twitter:description" content="7-day machine learning predictions for PLA aircraft sorties using ensemble models.">

    <!-- Theme -->
    <meta name="theme-color" content="#f5576c">
    <meta name="mobile-web-app-capable" content="yes">

    <!-- Structured Data -->
    <script type="application/ld+json">
    {
        "@context": "https://schema.org",
        "@type": "WebPage",
        "name": "ML Prediction - PLA Sorties Dashboard",
        "description": "7-day machine learning predictions for PLA aircraft sorties",
        "url": "https://s0914712.github.io/pla-data-dashboard/prediction.html",
        "isPartOf": {
            "@type": "WebSite",
            "name": "PLA Dashboard",
            "url": "https://s0914712.github.io/pla-data-dashboard/"
        }
    }
    </script>

    <!-- Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=GA_MEASUREMENT_ID"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
        gtag('config', 'GA_MEASUREMENT_ID');
    </script>

    <!-- Bootstrap CSS -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.6.2/dist/css/bootstrap.min.css">
    <!-- Chart.js -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js@3.9.1/dist/chart.min.js"></script>
    <!-- PapaParse for CSV parsing -->
    <script src="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js"></script>

    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: #f8f9fa;
        }

        .navbar-custom {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        }

        .navbar-custom .navbar-brand,
        .navbar-custom .nav-link {
            color: white !important;
        }

        .navbar-custom .nav-link:hover {
            color: #ddd !important;
        }

        .page-header {
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
            color: white;
            padding: 2rem 0;
            margin-bottom: 2rem;
        }

        .card-custom {
            background: white;
            border-radius: 10px;
            padding: 1.5rem;
            margin-bottom: 1.5rem;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }

        .risk-low {
            background: linear-gradient(135deg, #11998e 0%, #38ef7d 100%);
            color: white;
        }

        .risk-medium {
            background: linear-gradient(135deg, #f7971e 0%, #ffd200 100%);
            color: white;
        }

        .risk-high {
            background: linear-gradient(135deg, #eb3349 0%, #f45c43 100%);
            color: white;
        }

        .prediction-card {
            border-radius: 15px;
            padding: 1.5rem;
            margin-bottom: 1rem;
            transition: transform 0.3s;
        }

        .prediction-card:hover {
            transform: translateY(-3px);
        }

        .prediction-value {
            font-size: 2.5rem;
            font-weight: bold;
        }

        .prediction-range {
            font-size: 0.9rem;
            opacity: 0.9;
        }

        .chart-container {
            background: white;
            border-radius: 10px;
            padding: 2rem;
            margin-bottom: 2rem;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }

        .update-info {
            background: #e9ecef;
            border-radius: 8px;
            padding: 1rem;
            font-size: 0.85rem;
        }

        .table-responsive {
            border-radius: 10px;
            overflow: hidden;
        }

        table thead {
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
            color: white;
        }

        .badge-risk-low {
            background-color: #28a745;
        }

        .badge-risk-medium {
            background-color: #ffc107;
            color: #333;
        }

        .badge-risk-high {
            background-color: #dc3545;
        }

        .accuracy-card {
            background: white;
            border-radius: 10px;
            padding: 1.5rem;
            text-align: center;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            height: 100%;
        }

        .accuracy-value {
            font-size: 2rem;
            font-weight: bold;
            color: #f5576c;
        }

        .accuracy-label {
            font-size: 0.85rem;
            color: #6c757d;
        }

        .error-positive {
            color: #dc3545;
        }

        .error-negative {
            color: #28a745;
        }

        .error-zero {
            color: #6c757d;
        }

        .nav-tabs .nav-link.active {
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
            color: white;
            border: none;
        }

        .nav-tabs .nav-link {
            color: #f5576c;
        }

        .tab-content {
            background: white;
            border-radius: 0 0 10px 10px;
            padding: 1.5rem;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }

        /* ========== Mobile Optimizations ========== */

        /* Navigation - Fix hamburger menu icon visibility */
        .navbar-toggler {
            border: 2px solid rgba(255,255,255,0.5);
            padding: 0.5rem 0.75rem;
            min-height: 44px;
            min-width: 44px;
        }

        .navbar-toggler-icon {
            background-image: url("data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 30 30'%3e%3cpath stroke='rgba%28255, 255, 255, 1%29' stroke-linecap='round' stroke-miterlimit='10' stroke-width='2' d='M4 7h22M4 15h22M4 23h22'/%3e%3c/svg%3e");
        }

        .navbar-toggler:focus {
            outline: none;
            box-shadow: 0 0 0 3px rgba(255,255,255,0.3);
        }

        @media (max-width: 767.98px) {
            /* Header adjustments */
            .page-header {
                padding: 1.25rem 0;
                margin-bottom: 1rem;
            }

            .page-header h1 {
                font-size: 1.5rem;
            }

            .page-header .lead {
                font-size: 0.85rem;
            }

            /* Navigation dropdown */
            .navbar-collapse {
                background: rgba(102, 126, 234, 0.98);
                margin: 0.5rem -15px 0;
                padding: 0.5rem 15px;
                border-radius: 8px;
            }

            .navbar-nav .nav-link {
                padding: 0.75rem 1rem !important;
                border-bottom: 1px solid rgba(255,255,255,0.1);
                min-height: 44px;
                display: flex;
                align-items: center;
            }

            .navbar-nav .nav-item:last-child .nav-link {
                border-bottom: none;
            }

            /* Stat cards */
            .prediction-card {
                padding: 1rem;
            }

            .prediction-value {
                font-size: 1.75rem;
            }

            .prediction-range {
                font-size: 0.8rem;
            }

            .accuracy-card {
                padding: 1rem;
            }

            .accuracy-value {
                font-size: 1.5rem;
            }

            /* Chart container adjustments */
            .card-custom {
                padding: 1rem;
                margin-bottom: 1rem;
            }

            .chart-container canvas,
            .tab-content canvas {
                max-height: 250px !important;
            }

            .tab-content {
                padding: 1rem;
            }

            .tab-content h5 {
                font-size: 0.9rem;
            }

            /* Tabs: make tappable */
            .nav-tabs .nav-link {
                font-size: 0.8rem;
                padding: 0.6rem 0.75rem;
                min-height: 44px;
                display: flex;
                align-items: center;
            }

            /* Update info */
            .update-info {
                font-size: 0.75rem;
                padding: 0.75rem;
            }

            /* Table font size */
            .table-sm th,
            .table-sm td {
                font-size: 0.75rem;
                padding: 0.3rem 0.4rem;
            }

            /* Footer */
            footer {
                padding: 1.5rem 0 !important;
            }

            footer p {
                font-size: 0.85rem;
            }
        }

        /* Small phones */
        @media (max-width: 375px) {
            .page-header h1 {
                font-size: 1.25rem;
            }

            .prediction-value {
                font-size: 1.5rem;
            }

            .container {
                padding-left: 12px;
                padding-right: 12px;
            }

            .nav-tabs .nav-link {
                font-size: 0.7rem;
                padding: 0.5rem 0.5rem;
            }
        }

        /* Landscape phone */
        @media (max-width: 767.98px) and (orientation: landscape) {
            .page-header {
                padding: 0.75rem 0;
            }

            .chart-container canvas,
            .tab-content canvas {
                max-height: 200px !important;
            }
        }
    </style>
</head>
<body>

<!-- Navigation -->
<nav class="navbar navbar-expand-lg navbar-custom">
    <div class="container">
        <a class="navbar-brand" href="index.html">PLA Dashboard</a>
        <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNav">
            <span class="navbar-toggler-icon"></span>
        </button>
        <div class="collapse navbar-collapse" id="navbarNav">
            <ul class="navbar-nav ml-auto">
                <li class="nav-item"><a class="nav-link" href="index.html">Home</a></li>
                <li class="nav-item active"><a class="nav-link" href="prediction.html">ML Prediction</a></li>
                <li class="nav-item"><a class="nav-link" href="weather.html">Airport Weather</a></li>
                <li class="nav-item"><a class="nav-link" href="japan.html">Japan MOD</a></li>
                <li class="nav-item"><a class="nav-link" href="news.html">News</a></li>
                <li class="nav-item"><a class="nav-link" href="download.html">Download</a></li>
            </ul>
        </div>
    </div>
</nav>

<!-- Page Header -->
<div class="page-header">
    <div class="container">
        <h1>ML Prediction Agent</h1>
        <p class="lead">Machine Learning predictions for PLA aircraft sorties (7-day forecast)</p>
    </div>
</div>

<!-- Main Content -->
<div class="container">
    <!-- Update Info -->
    <div class="update-info mb-4">
        <strong>Model:</strong> <span id="modelVersion">-</span> |
        <strong>Data Latest:</strong> <span id="dataLatest">-</span> |
        <strong>Generated:</strong> <span id="generatedAt">-</span>
    </div>

    <!-- Stale Data Warning (shown dynamically) -->
    <div id="staleWarning" class="alert alert-warning mb-4" style="display: none;">
        <strong>Data Delay:</strong> <span id="staleWarningText"></span>
    </div>

    <!-- Prediction Cards -->
    <div class="row" id="predictionCards">
        <!-- Cards will be generated by JavaScript -->
    </div>

    <!-- Prediction Accuracy Section -->
    <div class="card-custom" id="accuracySection" style="display: none;">
        <h5>Model Accuracy Statistics (預測準確度統計)</h5>
        <div class="row mt-3">
            <div class="col-md-3 col-sm-6 mb-3">
                <div class="accuracy-card">
                    <div class="accuracy-label">Historical Predictions</div>
                    <div class="accuracy-value" id="totalPredictions">-</div>
                    <div class="accuracy-label">with actual data</div>
                </div>
            </div>
            <div class="col-md-3 col-sm-6 mb-3">
                <div class="accuracy-card">
                    <div class="accuracy-label">MAE (平均絕對誤差)</div>
                    <div class="accuracy-value" id="maeValue">-</div>
                    <div class="accuracy-label">架次 / sorties</div>
                </div>
            </div>
            <div class="col-md-3 col-sm-6 mb-3">
                <div class="accuracy-card">
                    <div class="accuracy-label">RMSE (均方根誤差)</div>
                    <div class="accuracy-value" id="rmseValue">-</div>
                    <div class="accuracy-label">架次 / sorties</div>
                </div>
            </div>
            <div class="col-md-3 col-sm-6 mb-3">
                <div class="accuracy-card">
                    <div class="accuracy-label">Direction Accuracy</div>
                    <div class="accuracy-value" id="directionAccuracy">-</div>
                    <div class="accuracy-label">高/低判斷正確率</div>
                </div>
            </div>
        </div>
    </div>

    <!-- Charts with Tabs -->
    <div class="card-custom">
        <ul class="nav nav-tabs" id="chartTabs" role="tablist">
            <li class="nav-item">
                <a class="nav-link active" id="forecast-tab" data-toggle="tab" href="#forecastPane" role="tab">7-Day Forecast</a>
            </li>
            <li class="nav-item">
                <a class="nav-link" id="accuracy-tab" data-toggle="tab" href="#accuracyPane" role="tab">Predicted vs Actual</a>
            </li>
            <li class="nav-item">
                <a class="nav-link" id="error-tab" data-toggle="tab" href="#errorPane" role="tab">Prediction Error</a>
            </li>
        </ul>
        <div class="tab-content" id="chartTabContent">
            <div class="tab-pane fade show active" id="forecastPane" role="tabpanel">
                <h5 class="mt-3">Historical Sorties (60 Days) + 7-Day Forecast (近60天實際值 + 7天預測)</h5>
                <canvas id="forecastChart"></canvas>
            </div>
            <div class="tab-pane fade" id="accuracyPane" role="tabpanel">
                <h5 class="mt-3">Predicted vs Actual Values (歷史預測 vs 實際值)</h5>
                <div id="accuracyNoData" style="display:none; text-align:center; padding:2rem; color:#666;">
                    <p>No historical prediction data with actual values available yet.</p>
                    <p>Data will appear once predictions have been made and actual values are recorded.</p>
                </div>
                <canvas id="accuracyChart"></canvas>
            </div>
            <div class="tab-pane fade" id="errorPane" role="tabpanel">
                <h5 class="mt-3">Prediction Error Over Time (預測誤差趨勢)</h5>
                <div id="errorNoData" style="display:none; text-align:center; padding:2rem; color:#666;">
                    <p>No historical prediction error data available yet.</p>
                    <p>Data will appear once predictions have been made and actual values are recorded.</p>
                </div>
                <canvas id="errorChart"></canvas>
            </div>
        </div>
    </div>

    <!-- Data Table -->
    <div class="card-custom">
        <h5>Prediction History (預測歷史記錄)</h5>
        <p class="text-muted">Showing all predictions with actual values when available</p>
        <div class="table-responsive" style="max-height: 500px; overflow-y: auto;">
            <table class="table table-striped table-hover table-sm">
                <thead>
                    <tr>
                        <th>Date</th>
                        <th>Day</th>
                        <th>Predicted</th>
                        <th>Actual</th>
                        <th>Error</th>
                        <th>95% CI</th>
                        <th>High Prob.</th>
                        <th>Risk</th>
                    </tr>
                </thead>
                <tbody id="predictionTableBody">
                </tbody>
            </table>
        </div>
    </div>

    <!-- Model Information -->
    <div class="card-custom">
        <h5>About the Prediction Model</h5>
        <div class="row">
            <div class="col-md-6">
                <h6>Ensemble Model (v2.0)</h6>
                <ul>
                    <li>Combines normal activity and high-activity models</li>
                    <li>Uses political signals (3-day and 7-day windows)</li>
                    <li>Incorporates day-of-week patterns</li>
                    <li>Provides confidence intervals</li>
                </ul>
            </div>
            <div class="col-md-6">
                <h6>Risk Level Definitions</h6>
                <ul>
                    <li><span class="badge badge-risk-low">LOW</span> - Normal activity expected</li>
                    <li><span class="badge badge-risk-medium">MEDIUM</span> - Elevated activity possible</li>
                    <li><span class="badge badge-risk-high">HIGH</span> - High activity likely</li>
                </ul>
            </div>
        </div>
    </div>
</div>

<!-- Footer -->
<footer class="text-center py-4 mt-5" style="background-color: #343a40; color: white;">
    <div class="container">
        <p>PLA Military Data Analysis Dashboard</p>
        <p>
            <a href="https://github.com/s0914712" target="_blank" style="color: #f093fb;">GitHub</a> |
            <a href="https://s0914712.github.io" target="_blank" style="color: #f093fb;">Blog</a>
        </p>
    </div>
</footer>

<!-- Scripts -->
<script src="https://code.jquery.com/jquery-3.5.1.slim.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/bootstrap@4.6.2/dist/js/bootstrap.bundle.min.js"></script>

<script>
let predictionData = [];
let allHistoricalData = [];
let actualSortiesData = {};  // Map: date -> sorties
let actualSortiesArray = []; // Array for chart display
let forecastChart = null;
let accuracyChart = null;
let errorChart = null;
const isMobile = window.innerWidth < 768;

window.addEventListener('load', async function() {
    await loadActualSortiesData();
    await loadPredictionData();
    await loadHistoricalPredictions();
    mergeActualWithPredictions();
    calculateAccuracyStats();
    renderPredictionCards();
    renderForecastChart();
    renderAccuracyChart();
    renderErrorChart();
    renderTable();
    showStaleDataWarning();

    // Fix: Charts in hidden Bootstrap tabs may render with zero dimensions.
    // Resize them when their tab becomes visible.
    $('a[data-toggle="tab"]').on('shown.bs.tab', function (e) {
        const target = $(e.target).attr('href');
        if (target === '#accuracyPane' && accuracyChart) {
            accuracyChart.resize();
        } else if (target === '#errorPane' && errorChart) {
            errorChart.resize();
        } else if (target === '#forecastPane' && forecastChart) {
            forecastChart.resize();
        }
    });
});

async function loadActualSortiesData() {
    try {
        const response = await fetch('data/JapanandBattleship.csv');
        const text = await response.text();
        const cleanText = text.replace(/^\uFEFF/, '');

        const parsed = Papa.parse(cleanText, {
            header: true,
            skipEmptyLines: true
        });

        // Build a map of date -> sorties for quick lookup
        const tempArray = parsed.data
            .filter(row => row.date && row.pla_aircraft_sorties && !isNaN(parseFloat(row.pla_aircraft_sorties)))
            .map(row => ({
                date: row.date.replace(/\//g, '-'),
                sorties: parseFloat(row.pla_aircraft_sorties)
            }))
            .sort((a, b) => new Date(a.date) - new Date(b.date));

        // Create lookup map
        tempArray.forEach(row => {
            actualSortiesData[row.date] = row.sorties;
        });

        // Get last 60 days for chart
        actualSortiesArray = tempArray.slice(-60);

        console.log('Loaded actual sorties:', Object.keys(actualSortiesData).length, 'records');
    } catch (error) {
        console.error('Error loading actual sorties data:', error);
    }
}

async function loadPredictionData() {
    try {
        // Load from new location: data/predictions/latest_prediction.csv
        const response = await fetch('data/predictions/latest_prediction.csv');
        const text = await response.text();
        const cleanText = text.replace(/^\uFEFF/, '');

        const parsed = Papa.parse(cleanText, {
            header: true,
            skipEmptyLines: true
        });

        // Get the 7-day forecast
        predictionData = parsed.data.filter(row => row.date && row.predicted_sorties);

        // Sort ascending for display
        predictionData.sort((a, b) => new Date(a.date) - new Date(b.date));

        if (predictionData.length > 0) {
            const latest = predictionData[predictionData.length - 1];
            document.getElementById('modelVersion').textContent = latest.model_version || '-';
            document.getElementById('dataLatest').textContent = latest.data_latest_date || '-';
            document.getElementById('generatedAt').textContent = latest.generated_at || '-';
        }

        console.log('Loaded latest predictions:', predictionData.length, 'records');
    } catch (error) {
        console.error('Error loading prediction data:', error);
    }
}

async function loadHistoricalPredictions() {
    try {
        // Try to load historical prediction files
        const historyFiles = [];
        const today = new Date();

        // Try to load the last 30 days of predictions
        for (let i = 1; i <= 30; i++) {
            const date = new Date(today);
            date.setDate(date.getDate() - i);
            // Use local date to avoid timezone shift (toISOString uses UTC which shifts dates for UTC+ timezones)
            const year = date.getFullYear();
            const month = String(date.getMonth() + 1).padStart(2, '0');
            const day = String(date.getDate()).padStart(2, '0');
            const dateStr = `${year}-${month}-${day}`;
            historyFiles.push(`data/predictions/history/prediction_${dateStr}.csv`);
        }

        const loadPromises = historyFiles.map(async (file) => {
            try {
                const response = await fetch(file);
                if (!response.ok) return [];
                const text = await response.text();
                const cleanText = text.replace(/^\uFEFF/, '');
                const parsed = Papa.parse(cleanText, { header: true, skipEmptyLines: true });
                return parsed.data;
            } catch {
                return [];
            }
        });

        const results = await Promise.all(loadPromises);

        // Flatten and deduplicate by date (keep earliest prediction for each date)
        const predictionMap = new Map();

        results.flat().forEach(row => {
            if (row.date && row.predicted_sorties) {
                // Only keep predictions for dates that have passed (we can compare with actual)
                const predDate = new Date(row.date);
                const today = new Date();
                today.setHours(0, 0, 0, 0);

                if (predDate < today) {
                    // Keep the earliest prediction made for this date
                    if (!predictionMap.has(row.date)) {
                        predictionMap.set(row.date, row);
                    }
                }
            }
        });

        allHistoricalData = Array.from(predictionMap.values());

        // Sort by date descending
        allHistoricalData.sort((a, b) => new Date(b.date) - new Date(a.date));

        console.log('Loaded historical predictions:', allHistoricalData.length, 'records');
    } catch (error) {
        console.error('Error loading historical predictions:', error);
    }
}

function mergeActualWithPredictions() {
    // Merge actual values into historical predictions
    allHistoricalData = allHistoricalData.map(row => {
        const actualValue = actualSortiesData[row.date];
        if (actualValue !== undefined) {
            const predicted = parseFloat(row.predicted_sorties);
            const error = actualValue - predicted;
            return {
                ...row,
                actual_sorties: actualValue,
                prediction_error: error
            };
        }
        return row;
    });

    // Also update current predictions with actual values if available
    predictionData = predictionData.map(row => {
        const actualValue = actualSortiesData[row.date];
        if (actualValue !== undefined) {
            const predicted = parseFloat(row.predicted_sorties);
            const error = actualValue - predicted;
            return {
                ...row,
                actual_sorties: actualValue,
                prediction_error: error
            };
        }
        return row;
    });

    console.log('Merged actual values with predictions');
}

function calculateAccuracyStats() {
    // Filter records with actual values (actual_sorties can be number or string)
    const withActual = allHistoricalData.filter(row => {
        const actual = row.actual_sorties;
        return actual !== undefined && actual !== null && actual !== '' && !isNaN(parseFloat(actual));
    });

    if (withActual.length === 0) {
        document.getElementById('accuracySection').style.display = 'none';
        return;
    }

    document.getElementById('accuracySection').style.display = 'block';
    document.getElementById('totalPredictions').textContent = withActual.length;

    // Calculate errors
    let sumAbsError = 0;
    let sumSquaredError = 0;
    let correctDirection = 0;
    let totalComparisons = 0;

    withActual.forEach(row => {
        const predicted = parseFloat(row.predicted_sorties);
        const actual = typeof row.actual_sorties === 'number' ? row.actual_sorties : parseFloat(row.actual_sorties);

        if (!isNaN(predicted) && !isNaN(actual)) {
            const error = actual - predicted;
            sumAbsError += Math.abs(error);
            sumSquaredError += error * error;

            // Direction accuracy (using 30 as threshold)
            const predHigh = predicted >= 30;
            const actualHigh = actual >= 30;
            if (predHigh === actualHigh) correctDirection++;
            totalComparisons++;
        }
    });

    const mae = sumAbsError / withActual.length;
    const rmse = Math.sqrt(sumSquaredError / withActual.length);
    const directionAcc = totalComparisons > 0 ? (correctDirection / totalComparisons * 100) : 0;

    document.getElementById('maeValue').textContent = mae.toFixed(1);
    document.getElementById('rmseValue').textContent = rmse.toFixed(1);
    document.getElementById('directionAccuracy').textContent = directionAcc.toFixed(0) + '%';
}

function showStaleDataWarning() {
    if (predictionData.length === 0) return;
    const dataLatest = predictionData[predictionData.length - 1].data_latest_date;
    if (!dataLatest) return;

    const latestDate = new Date(dataLatest);
    const today = new Date();
    today.setHours(0, 0, 0, 0);
    const diffDays = Math.floor((today - latestDate) / (1000 * 60 * 60 * 24));

    if (diffDays > 1) {
        const warningEl = document.getElementById('staleWarning');
        const textEl = document.getElementById('staleWarningText');
        textEl.textContent = `The latest available data is from ${dataLatest} (${diffDays} days ago). Predictions for dates that have already passed may be inaccurate. Data source may need to be updated.`;
        warningEl.style.display = 'block';
    }
}

function getRiskClass(level) {
    switch(level?.toUpperCase()) {
        case 'LOW': return 'risk-low';
        case 'MEDIUM': return 'risk-medium';
        case 'HIGH': return 'risk-high';
        default: return 'risk-low';
    }
}

function getRiskBadgeClass(level) {
    switch(level?.toUpperCase()) {
        case 'LOW': return 'badge-risk-low';
        case 'MEDIUM': return 'badge-risk-medium';
        case 'HIGH': return 'badge-risk-high';
        default: return 'badge-risk-low';
    }
}

function renderPredictionCards() {
    const container = document.getElementById('predictionCards');
    container.innerHTML = '';

    const today = new Date();
    today.setHours(0, 0, 0, 0);

    predictionData.forEach((row, index) => {
        const riskClass = getRiskClass(row.risk_level);
        const predicted = parseFloat(row.predicted_sorties).toFixed(1);
        const lower = parseFloat(row.lower_bound).toFixed(1);
        const upper = parseFloat(row.upper_bound).toFixed(1);
        const highProb = parseFloat(row.high_event_probability).toFixed(1);

        const date = new Date(row.date);
        const dateStr = date.toLocaleDateString('zh-TW', { month: 'short', day: 'numeric' });

        // Check if this date has already passed
        const isPast = date < today;

        // Check if actual value exists
        const hasActual = row.actual_sorties && row.actual_sorties !== '' && !isNaN(parseFloat(row.actual_sorties));
        const actualVal = hasActual ? parseFloat(row.actual_sorties).toFixed(0) : null;
        const errorVal = hasActual ? (parseFloat(row.actual_sorties) - parseFloat(row.predicted_sorties)).toFixed(1) : null;

        // Past dates without actual data get a muted style
        const pastStyle = (isPast && !hasActual) ? 'opacity: 0.6;' : '';
        const pastLabel = isPast ? '<span style="font-size:0.7rem; background:rgba(0,0,0,0.2); padding:1px 6px; border-radius:3px;">Past</span>' : '';

        const cardHtml = `
            <div class="col-md-3 col-sm-6">
                <div class="prediction-card ${riskClass}" style="${pastStyle}">
                    <div class="text-center">
                        <div style="font-size: 0.9rem; opacity: 0.9;">${dateStr} (${row.day_of_week}) ${pastLabel}</div>
                        <div class="prediction-value">${predicted}</div>
                        <div class="prediction-range">Range: ${lower} - ${upper}</div>
                        ${hasActual ? `
                            <div style="margin-top: 0.5rem; background: rgba(255,255,255,0.2); padding: 0.3rem; border-radius: 5px;">
                                <small>Actual: <strong>${actualVal}</strong> (${errorVal >= 0 ? '+' : ''}${errorVal})</small>
                            </div>
                        ` : isPast ? `
                            <div style="margin-top: 0.5rem;">
                                <small style="opacity:0.8;">Awaiting actual data</small>
                            </div>
                        ` : `
                            <div style="margin-top: 0.5rem;">
                                <small>High Event: ${highProb}%</small>
                            </div>
                        `}
                    </div>
                </div>
            </div>
        `;
        container.innerHTML += cardHtml;
    });
}

function renderForecastChart() {
    const ctx = document.getElementById('forecastChart').getContext('2d');

    // Combine historical actual data (60 days) + future predictions (7 days)
    const combinedLabels = [];
    const actualData = [];
    const predictedData = [];
    const upperData = [];
    const lowerData = [];

    // Add historical actual data (last 60 days)
    actualSortiesArray.forEach(row => {
        const date = new Date(row.date);
        combinedLabels.push(date.toLocaleDateString('zh-TW', { month: 'numeric', day: 'numeric' }));
        actualData.push(row.sorties);
        predictedData.push(null);  // No prediction for historical dates
        upperData.push(null);
        lowerData.push(null);
    });

    // Add 7-day predictions
    predictionData.forEach(row => {
        const date = new Date(row.date);
        const dateLabel = date.toLocaleDateString('zh-TW', { month: 'numeric', day: 'numeric' });

        // Check if this date already exists in labels (might have actual data)
        const existingIdx = combinedLabels.indexOf(dateLabel);
        if (existingIdx === -1) {
            combinedLabels.push(dateLabel);
            actualData.push(row.actual_sorties && row.actual_sorties !== '' ? parseFloat(row.actual_sorties) : null);
            predictedData.push(parseFloat(row.predicted_sorties));
            upperData.push(parseFloat(row.upper_bound));
            lowerData.push(parseFloat(row.lower_bound));
        } else {
            // Update existing entry with prediction data
            predictedData[existingIdx] = parseFloat(row.predicted_sorties);
            upperData[existingIdx] = parseFloat(row.upper_bound);
            lowerData[existingIdx] = parseFloat(row.lower_bound);
        }
    });

    forecastChart = new Chart(ctx, {
        type: 'line',
        data: {
            labels: combinedLabels,
            datasets: [
                {
                    label: 'Actual Sorties (實際架次)',
                    data: actualData,
                    borderColor: '#667eea',
                    backgroundColor: 'rgba(102, 126, 234, 0.1)',
                    borderWidth: isMobile ? 1.5 : 2,
                    fill: false,
                    tension: 0.3,
                    pointRadius: isMobile ? 1 : 2,
                    pointHitRadius: isMobile ? 15 : 10,
                    pointBackgroundColor: '#667eea'
                },
                {
                    label: 'Predicted (預測)',
                    data: predictedData,
                    borderColor: '#f5576c',
                    backgroundColor: 'rgba(245, 87, 108, 0.1)',
                    borderWidth: isMobile ? 2 : 3,
                    fill: false,
                    tension: 0.4,
                    pointRadius: isMobile ? 3 : 5,
                    pointHitRadius: isMobile ? 15 : 10,
                    pointBackgroundColor: '#f5576c'
                },
                {
                    label: 'Upper Bound (95% CI)',
                    data: upperData,
                    borderColor: 'rgba(245, 87, 108, 0.4)',
                    borderWidth: 1,
                    borderDash: [5, 5],
                    fill: false,
                    pointRadius: 0
                },
                {
                    label: 'Lower Bound (95% CI)',
                    data: lowerData,
                    borderColor: 'rgba(245, 87, 108, 0.4)',
                    borderWidth: 1,
                    borderDash: [5, 5],
                    fill: '-1',
                    backgroundColor: 'rgba(245, 87, 108, 0.1)',
                    pointRadius: 0
                }
            ]
        },
        options: {
            responsive: true,
            maintainAspectRatio: !isMobile,
            plugins: {
                legend: {
                    position: 'top',
                    labels: {
                        boxWidth: isMobile ? 8 : 40,
                        font: { size: isMobile ? 9 : 12 },
                        padding: isMobile ? 8 : 10
                    }
                },
                tooltip: { mode: 'index', intersect: false },
                annotation: {
                    annotations: {
                        line1: {
                            type: 'line',
                            xMin: actualSortiesArray.length - 0.5,
                            xMax: actualSortiesArray.length - 0.5,
                            borderColor: 'rgba(0, 0, 0, 0.3)',
                            borderWidth: 2,
                            borderDash: [6, 6],
                            label: {
                                content: 'Forecast Start',
                                enabled: true
                            }
                        }
                    }
                }
            },
            scales: {
                x: {
                    ticks: {
                        maxTicksLimit: isMobile ? 6 : 15,
                        maxRotation: isMobile ? 60 : 45,
                        minRotation: 0,
                        font: { size: isMobile ? 9 : 12 }
                    }
                },
                y: {
                    beginAtZero: true,
                    title: {
                        display: !isMobile,
                        text: 'Aircraft Sorties (架次)'
                    },
                    ticks: {
                        font: { size: isMobile ? 9 : 12 }
                    }
                }
            }
        }
    });
}

function renderAccuracyChart() {
    const ctx = document.getElementById('accuracyChart').getContext('2d');

    // Get records with actual values (actual_sorties can be number or string)
    const withActual = allHistoricalData
        .filter(r => {
            const actual = r.actual_sorties;
            return actual !== undefined && actual !== null && actual !== '' && !isNaN(parseFloat(actual));
        })
        .slice(0, 60)
        .reverse();

    if (withActual.length === 0) {
        document.getElementById('accuracyChart').style.display = 'none';
        document.getElementById('accuracyNoData').style.display = 'block';
        return;
    }

    document.getElementById('accuracyChart').style.display = 'block';
    document.getElementById('accuracyNoData').style.display = 'none';

    const labels = withActual.map(r => {
        const date = new Date(r.date);
        return date.toLocaleDateString('zh-TW', { month: 'numeric', day: 'numeric' });
    });

    const predicted = withActual.map(r => parseFloat(r.predicted_sorties));
    const actual = withActual.map(r => typeof r.actual_sorties === 'number' ? r.actual_sorties : parseFloat(r.actual_sorties));

    accuracyChart = new Chart(ctx, {
        type: 'line',
        data: {
            labels: labels,
            datasets: [
                {
                    label: 'Predicted (預測值)',
                    data: predicted,
                    borderColor: '#f5576c',
                    backgroundColor: 'rgba(245, 87, 108, 0.1)',
                    borderWidth: isMobile ? 1.5 : 2,
                    fill: false,
                    tension: 0.3,
                    pointRadius: isMobile ? 2 : 4,
                    pointHitRadius: isMobile ? 15 : 10,
                    pointBackgroundColor: '#f5576c'
                },
                {
                    label: 'Actual (實際值)',
                    data: actual,
                    borderColor: '#28a745',
                    backgroundColor: 'rgba(40, 167, 69, 0.1)',
                    borderWidth: isMobile ? 1.5 : 2,
                    fill: false,
                    tension: 0.3,
                    pointRadius: isMobile ? 2 : 4,
                    pointHitRadius: isMobile ? 15 : 10,
                    pointBackgroundColor: '#28a745'
                }
            ]
        },
        options: {
            responsive: true,
            maintainAspectRatio: !isMobile,
            plugins: {
                legend: {
                    position: 'top',
                    labels: {
                        boxWidth: isMobile ? 8 : 40,
                        font: { size: isMobile ? 9 : 12 },
                        padding: isMobile ? 8 : 10
                    }
                },
                tooltip: {
                    mode: 'index',
                    intersect: false,
                    callbacks: {
                        afterBody: function(context) {
                            const idx = context[0].dataIndex;
                            const pred = predicted[idx];
                            const act = actual[idx];
                            const err = act - pred;
                            return `Error: ${err > 0 ? '+' : ''}${err.toFixed(1)}`;
                        }
                    }
                }
            },
            scales: {
                x: {
                    ticks: {
                        maxTicksLimit: isMobile ? 6 : 15,
                        font: { size: isMobile ? 9 : 12 }
                    }
                },
                y: {
                    beginAtZero: true,
                    title: { display: !isMobile, text: 'Aircraft Sorties (架次)' },
                    ticks: { font: { size: isMobile ? 9 : 12 } }
                }
            }
        }
    });
}

function renderErrorChart() {
    const ctx = document.getElementById('errorChart').getContext('2d');

    // Get records with prediction_error (can be number from merge or string from CSV)
    const withActual = allHistoricalData
        .filter(r => {
            const err = r.prediction_error;
            return err !== undefined && err !== null && err !== '' && !isNaN(parseFloat(err));
        })
        .slice(0, 60)
        .reverse();

    if (withActual.length === 0) {
        document.getElementById('errorChart').style.display = 'none';
        document.getElementById('errorNoData').style.display = 'block';
        return;
    }

    document.getElementById('errorChart').style.display = 'block';
    document.getElementById('errorNoData').style.display = 'none';

    const labels = withActual.map(r => {
        const date = new Date(r.date);
        return date.toLocaleDateString('zh-TW', { month: 'numeric', day: 'numeric' });
    });

    const errors = withActual.map(r => typeof r.prediction_error === 'number' ? r.prediction_error : parseFloat(r.prediction_error));
    const colors = errors.map(e => e > 0 ? 'rgba(220, 53, 69, 0.7)' : 'rgba(40, 167, 69, 0.7)');

    errorChart = new Chart(ctx, {
        type: 'bar',
        data: {
            labels: labels,
            datasets: [{
                label: 'Prediction Error (預測誤差: 實際 - 預測)',
                data: errors,
                backgroundColor: colors,
                borderColor: colors.map(c => c.replace('0.7', '1')),
                borderWidth: 1
            }]
        },
        options: {
            responsive: true,
            maintainAspectRatio: !isMobile,
            plugins: {
                legend: {
                    position: 'top',
                    labels: {
                        boxWidth: isMobile ? 8 : 40,
                        font: { size: isMobile ? 9 : 12 }
                    }
                },
                tooltip: {
                    callbacks: {
                        label: function(context) {
                            const value = context.raw;
                            return `Error: ${value > 0 ? '+' : ''}${value.toFixed(1)} (${value > 0 ? 'Underestimated 低估' : 'Overestimated 高估'})`;
                        }
                    }
                }
            },
            scales: {
                x: {
                    ticks: {
                        maxTicksLimit: isMobile ? 6 : 15,
                        font: { size: isMobile ? 9 : 12 }
                    }
                },
                y: {
                    title: { display: !isMobile, text: 'Error (Actual - Predicted) 誤差' },
                    ticks: { font: { size: isMobile ? 9 : 12 } }
                }
            }
        }
    });
}

function renderTable() {
    const tbody = document.getElementById('predictionTableBody');
    tbody.innerHTML = '';

    // Combine current predictions with historical data for the table
    const allData = [...predictionData, ...allHistoricalData];

    // Deduplicate by date (prefer entries with actual values)
    const dateMap = new Map();
    allData.forEach(row => {
        if (!row.date) return;
        const existing = dateMap.get(row.date);
        const hasActual = row.actual_sorties !== undefined && row.actual_sorties !== null && row.actual_sorties !== '';
        if (!existing || (hasActual && !existing.actual_sorties)) {
            dateMap.set(row.date, row);
        }
    });

    // Sort by date descending
    const sortedData = Array.from(dateMap.values()).sort((a, b) => new Date(b.date) - new Date(a.date));

    sortedData.forEach(row => {
        const badgeClass = getRiskBadgeClass(row.risk_level);
        const actual = row.actual_sorties;
        const hasActual = actual !== undefined && actual !== null && actual !== '' && !isNaN(parseFloat(actual));
        const actualVal = hasActual ? (typeof actual === 'number' ? actual.toFixed(0) : parseFloat(actual).toFixed(0)) : '-';

        let errorHtml = '-';
        const err = row.prediction_error;
        if (err !== undefined && err !== null && err !== '' && !isNaN(parseFloat(err))) {
            const errNum = typeof err === 'number' ? err : parseFloat(err);
            const errorClass = errNum > 0 ? 'error-positive' : (errNum < 0 ? 'error-negative' : 'error-zero');
            errorHtml = `<span class="${errorClass}">${errNum > 0 ? '+' : ''}${errNum.toFixed(1)}</span>`;
        }

        const tr = document.createElement('tr');
        tr.innerHTML = `
            <td>${row.date}</td>
            <td>${row.day_of_week || '-'}</td>
            <td><strong>${parseFloat(row.predicted_sorties).toFixed(1)}</strong></td>
            <td>${actualVal}</td>
            <td>${errorHtml}</td>
            <td>${parseFloat(row.lower_bound).toFixed(0)} - ${parseFloat(row.upper_bound).toFixed(0)}</td>
            <td>${parseFloat(row.high_event_probability).toFixed(1)}%</td>
            <td><span class="badge ${badgeClass}">${row.risk_level}</span></td>
        `;
        tbody.appendChild(tr);
    });
}
</script>

</body>
</html>
